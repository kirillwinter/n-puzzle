import search.interfaces.IHeuristicFunction;

import java.util.ArrayList;
import java.util.List;

/**
 * An implementation of IDA* search to find an optimal path in a state space.
 */
public class IDAStarSearch {

    private Node initialState;
    private long countOpen = 0;
    private IHeuristicFunction heuristicFunction;

    /**
     * Creates an IDAStarSearch object with initial state, goal state, and a heuristic function.
     *
     * @param initialState      the state where the search begins
     * @param heuristicFunction the heuristic function used to score nodes
     */
    public IDAStarSearch(Node initialState,
                         IHeuristicFunction heuristicFunction) {
        this.initialState = initialState;
        this.heuristicFunction = heuristicFunction;
    }

    /**
     * Begins the IDA* search. Will return null if the goal node cannot be found. Returns a Node that
     * is the last node on the optimal path. You can traverse the optimal path by following each nodes parent
     * until you arrive back to the initial node(parent is null).
     *
     * @return null if path does not exist, otherwise the last node on the optimal path
     */
    public Node search() {

        // Find Initial F Bound
        int currentFBound = this.heuristicFunction.calculateHeuristic(this.initialState);

        countOpen++;

        // Set Root of Path To Initial Node
        ArrayList<Node> path = new ArrayList<>();
        path.add(0, this.initialState);

        // Keep Retrying With Larger F Bound Until One Of The Follow:
        // 0 Is Returned     - The Goal Node Is Found So Path Contains Optimal Path
        // Integer.MAX_Value - No Node Was Found With A F Higher Than F Boundary So Goal Node Does Not Exist
        int smallestNewFBound;
        do {
            // Start Search
            smallestNewFBound = recur_search(path, 0, currentFBound);

            // Check If Goal Node Was Found
            if (smallestNewFBound == 0)
                return path.get(path.size() - 1);

            // Set New F Boundary
            currentFBound = smallestNewFBound;


            System.out.println(path.size());
        } while (currentFBound != Integer.MAX_VALUE);

        return null;
    }

    /**
     * Recursively searches down the children of nodes. Will prevent itself from search down path with higher f than
     * current f boundary. If paths with higher f boundary are found then it will return the smallest f over the
     * boundary found. This smallest f over f boundary is a potential new f boundary during the next iteration. Will
     * return 0 if goal node is found and Integer.MAX_VALUE if there is not a single path with a f greater than the
     * f boundary, meaning the goal node cannot be found.
     *
     * @param path          list of nodes ordered by the order they were visited
     * @param graphCost     current graph cost to get to the current node
     * @param currentFBound the max f boundary for current iteration
     * @return the smallest f value in the iteration that was greater than the fBoundary for the iteration
     */
    private int recur_search(ArrayList<Node> path, int graphCost, int currentFBound) {

        // Set G, H, and F of Current Node
        Node currentNode = path.get(path.size() - 1);
        currentNode.setH(this.heuristicFunction.calculateHeuristic(currentNode));
        currentNode.setG(graphCost);
        currentNode.setF(graphCost + currentNode.getH());

        // Current Node Has F Larger Than Current Bound
        if (currentNode.getF() > currentFBound)
            return currentNode.getF();

//        // Found The Goal Node -> Send Signal To End Recursion
//        if (currentNode.equals(this.goalState))
//            return 0;

//        System.out.println("h = " + currentNode.getH() + " path = " + path.size() );

        if (currentNode.getH() == 0)
            return 0;

        // If This Stays Integer.MAX_VALUE Then All Paths Explored Were Smaller Than F Bound
        int minFFound = Integer.MAX_VALUE;

        List<Node> children = currentNode.getSuccessors();
        // Expand Search To Each Child Node
        for (Node child : children) {

            // Verify Child Node Is Not Already On The Current Search Path
            if (!path.contains(child)) {

                // Add Child Tp Path And Then Continue Search Down The Path
                path.add(child);


                int minFOverBound = recur_search(path, currentNode.getG() + child.distFromParent(), currentFBound);

                // Signals To End Recursion When Goal Is Found
                if (minFOverBound == 0)
                    return 0;


                // Keep Track Of The Smallest F Found Over Bound Generated By Each Child's Search Path
                if (minFOverBound < minFFound)
                    minFFound = minFOverBound;

                // Remove Child From Search Path Before Exploring Next Child
                path.remove(path.size() - 1);
            }
        }

        return minFFound;
    }

    /**
     * Takes the output from search() and makes it into a list of states that represent the optimal path from the
     * initial state to the goal state.
     *
     * @param endPathNode the output node from search()
     * @return an list of nodes ordered to represent the optimal path
     */


    public long getCountOpen() {
        return countOpen;
    }
}
